import numpy as np  # 7
n = 8
width = 5

ways = np.zeros((n, n), int)
for i in range(1, width//2+1):
    ways += np.diag(np.random.randint(1, 100, n-i), i)
    ways += np.diag(np.random.randint(1, 100, n-i), -i)
ways[0][2] = 0
ways[2][0] = ways[0][2]
ways[0][3] = np.random.randint(1, 100)
ways[3][0] = ways[0][3]
np.fill_diagonal(ways, 0)
print(ways)


def arg_min(T, S):
    amin = -1
    m = 1000000  # максимальное значение
    for i, t in enumerate(T):
        if t < m and i not in S:
            m = t
            amin = i
    return amin


def get_link_v(v, D):
    for i, weight in enumerate(D[v]):
        if weight > 0:
            yield i


N = len(ways)  # число вершин в графе
T = [10000]*N   # список с весами(кратчайшими расстояниями до каждой вершины)

v = 0       # стартовая вершина (нумерация с нуля)
S = {v}     # просмотренные вершины
T[v] = 0    # нулевой вес для стартовой вершины
M = [0]*N   # оптимальные связи между вершинами

while v != -1:          # цикл, пока не просмотрим все вершины
    print('Рассматриваемая вершина', v+1)
    # перебираем все связанные вершины с вершиной v
    for j in get_link_v(v, ways):  # Находим все вершины связанные с данной
        if j not in S:           # если вершина еще не просмотрена
            # прибавляем вес данной вершины и кратчайшее расстояние до нее
            w = T[v] + ways[v][j]
            print('Вес из ', v+1, 'в', j+1, ' = ' +
                  str(T[v]) + ' + ' + str(ways[v][j]) + ' = ', w)
            if w < T[j]:  # если вес получился меньше того который уже есть
                T[j] = w  # сохраняем его
                # связываем вершину j с вершиной v, т.е каждому индексу будет соответсвовать вершина с ближайшем расстоянием
                M[j] = v
    v = arg_min(T, S)            # выбираем следующий узел с наименьшим весом

    if v >= 0:                    # выбрана очередная вершина
        print('Выбрана оптимальная вершина ', v+1)
        S.add(v)                 # добавляем новую вершину в рассмотрение
# формирование оптимального маршрута:
start = 0
end = 10
P = [end]  # список маршрута
while end != start:  # цикл
    # присваиваем end значение равное M[значение элемента P[-1]] т. вместо индекса значение элемента P[-1] для лучшего понимания можешь вывести эти два массива print(P, M)
    end = M[P[-1]]
    P.append(end)  # Добавляем end в массив путей
print('Кратчайший путь')

for i in range(len(P)):  # формируем вывод
    P[i] = str(P[i]+1)
print('->'.join(reversed(P)))
print('Кратчайший путь займет ', T[-1])
